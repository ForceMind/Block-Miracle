<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>奇迹跳跃｜JumpX (Patterns + Mechanics)</title>
  <style>
    :root{ --bg:#0b1220; --ink:#e6f0ff; --accent:#6be675; --accent2:#8bd1ff; --danger:#ff6b6b; --gold:#ffd166; --ui:#111827cc; }
    html,body{height:100%}
    body{margin:0;background:linear-gradient(#0b1220,#16223c 70%,#0b1220);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,"PingFang SC","Microsoft YaHei",sans-serif;overflow:hidden}
    #wrap{position:relative;height:100vh}
    canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering:pixelated}
    .hud{position:absolute;left:12px;top:12px;display:flex;gap:12px;align-items:center;background:var(--ui);padding:8px 10px;border-radius:12px;backdrop-filter:blur(6px)}
    .hud .pill{padding:4px 10px;border-radius:999px;background:#0f172acc}
    .hud .pill b{color:var(--gold)}
    .buttons{position:absolute;right:12px;top:12px;display:flex;gap:8px}
    .buttons button{background:#111827;color:var(--ink);border:1px solid #24324d;border-radius:10px;padding:8px 12px;cursor:pointer}
    .buttons button:hover{filter:brightness(1.1)}
    .legend{position:absolute;left:12px;bottom:12px;background:#0f172a99;padding:8px 10px;border-radius:10px}
    .legend kbd{background:#0b1220;border:1px solid #24324d;border-radius:6px;padding:2px 6px;margin:0 2px}
    .mobile{position:absolute;inset:auto 0 16px 0;display:flex;justify-content:space-between;align-items:center;padding:0 16px;pointer-events:none}
    .pad{display:flex;gap:10px;pointer-events:auto}
    .pad button{width:56px;height:56px;border-radius:50%;border:none;background:#0f172acc;color:var(--ink);font-weight:700;font-size:16px;box-shadow:0 4px 12px #0006;backdrop-filter:blur(6px)}
    .pad button:active{transform:scale(.95)}
    @media (min-width:900px){.mobile{display:none}}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="720" aria-label="Game Canvas"></canvas>

  <div class="hud" id="hud">
    <div class="pill">❤ <span id="hp">3</span></div>
    <div class="pill">★ <b id="coins">0</b></div>
    <div class="pill">里程 <span id="dist">0</span>m</div>
    <div class="pill">旗帜 <span id="chk">A</span></div>
    <div class="pill">跳×<span id="jumps">2</span></div>
  </div>
  <div class="buttons">
    <button id="btnRestart">重新开始 R</button>
    <button id="btnPause">暂停 P</button>
  </div>

  <div class="legend">
    操作：<kbd>←</kbd>/<kbd>A</kbd> 左，<kbd>→</kbd>/<kbd>D</kbd> 右，<kbd>Space</kbd>/<kbd>K</kbd> 跳（含土狼时间与缓冲，支持二段跳），<kbd>R</kbd> 重开，<kbd>P</kbd> 暂停。
  </div>

  <div class="mobile">
    <div class="pad"><button id="btnLeft">←</button><button id="btnRight">→</button></div>
    <div class="pad"><button id="btnJump">跳</button></div>
  </div>
</div>

<script>
(() => {
  // ===== 基础工具 =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const now = ()=>performance.now();
  const rand = (a,b)=>a + Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));

  // ===== 画布与尺寸 =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;
  const resize = () => {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const {clientWidth, clientHeight} = canvas;
    canvas.width = Math.round(clientWidth * dpr);
    canvas.height = Math.round(clientHeight * dpr);
    W = canvas.width; H = canvas.height;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  };
  new ResizeObserver(resize).observe(canvas);

  // ===== 输入 =====
  const keys = new Set();
  const input = {left:false,right:false,jump:false,jumpPressed:false};
  const updateInput = ()=>{
    input.left = keys.has('ArrowLeft') || keys.has('KeyA');
    input.right= keys.has('ArrowRight')|| keys.has('KeyD');
    input.jump = keys.has('Space') || keys.has('KeyK');
  };
  window.addEventListener('keydown', e=>{
    keys.add(e.code);
    if(['ArrowLeft','ArrowRight','Space','KeyA','KeyD','KeyK'].includes(e.code)) e.preventDefault();
    if(e.code==='KeyR') restart();
    if(e.code==='KeyP') togglePause();
  });
  window.addEventListener('keyup', e=>keys.delete(e.code));
  const bindHold=(el,on,off)=>{
    const s=e=>{e.preventDefault();on();};
    const u=e=>{e.preventDefault();off();};
    el.addEventListener('touchstart',s,{passive:false});
    el.addEventListener('touchend',u,{passive:false});
    el.addEventListener('touchcancel',u,{passive:false});
    el.addEventListener('mousedown',s);
    window.addEventListener('mouseup',u);
  };
  bindHold(document.getElementById('btnLeft'), ()=>keys.add('ArrowLeft'), ()=>keys.delete('ArrowLeft'));
  bindHold(document.getElementById('btnRight'),()=>keys.add('ArrowRight'),()=>keys.delete('ArrowRight'));
  bindHold(document.getElementById('btnJump'), ()=>{keys.add('Space'); setTimeout(()=>keys.delete('Space'), 50);}, ()=>keys.delete('Space'));
  document.getElementById('btnRestart').onclick=()=>restart();
  document.getElementById('btnPause').onclick=()=>togglePause();

  // ===== 关卡（程序化生成，Y 向下为正；80% 轻跑、20% 跳台） =====
  const GROUND_Y = 600; // 地面顶面 y
  const SEG_W = 640;     // 分段宽度
  const EASY_GAP = 120;  // 轻跑：最大水平空隙
  const HARD_GAP = 160;  // 跳台：最大水平空隙
  const EASY_STEP = 90;  // 轻跑：最大向上高度差
  const HARD_STEP = 140; // 跳台：最大向上高度差

  const level = {
    spawn:{x:64, y:GROUND_Y-56},
    platforms:[], spikes:[], coins:[], checkpoints:[],
    movers:[], springs:[], bricks:[],
    rightEdge: -400,
  };

  function addPlatform(x,y,w,h){ level.platforms.push({x,y,w,h}); }
  function addSpike(x,y,w,h){ level.spikes.push({x,y,w,h}); }
  function addCoin(x,y){ level.coins.push({x,y}); }
  function addCheckpoint(x,id){ level.checkpoints.push({x,y:GROUND_Y-64,id}); }
  function addMover(x,y,w,h,ax,bx,speed){ level.movers.push({x,y,w,h,ax,bx,speed,dir:1,vx:0}); }
  function addSpring(x,y,power=1000){ level.springs.push({x,y,w:20,h:12,power}); }
  function addBrick(x,y,w=32,h=24,hits=1){ level.bricks.push({x,y,w,h,hits}); }

  // 初始地面
  addPlatform(-400,GROUND_Y, 1200,80);
  level.rightEdge = 800;
  addCheckpoint(600,'A');

  // ===== 新AI关卡生成器：平台链+事件点，流畅且逻辑 =====
  function generateSegment(){
    const startX = level.rightEdge;
    const endX = startX + SEG_W;
    // 平台链参数
    let chainLen = randi(4,6);
    let lastY = randi(GROUND_Y-120, GROUND_Y-80);
    let lastX = startX + randi(60,100);
    let lastW = randi(120,180);
    for(let i=0;i<chainLen;i++){
      // 平台宽度递进有序
      const w = clamp(lastW + randi(-20,30), 100, 220);
      // 间隔递进有序，保证可跳跃
      const dx = clamp(randi(80, 140) + i*8, 80, 180);
      // 高度变化平滑且有序
      let y = clamp(lastY + randi(-40,40), GROUND_Y-200, GROUND_Y-60);
      // 保证不会突然高低错落
      if(Math.abs(y-lastY)>60) y = lastY + Math.sign(y-lastY)*60;
      const x = Math.min(lastX + dx, endX - 120);
      // 90% 固定台，10%移动台
      if(Math.random()<0.1) addMover(x,y,w,18, x-60, x+60, rand(40,70));
      else addPlatform(x,y,w,24);
      // 事件点：
      // 20%弹簧
      if(Math.random()<0.2) addSpring(x+w*0.5, y-12, randi(950,1200));
      // 30%金币串
      if(Math.random()<0.3){ const cN = randi(2,4); for(let k=0;k<cN;k++) addCoin(x+18+k*18, y-38); }
      // 15%碎砖
      if(Math.random()<0.15){ for(let t=0;t<randi(2,4);t++){ addBrick(x+16+t*34, y-40, 32, 24, 1); } }
      lastX = x; lastY = y; lastW = w;
    }
    // 地面连续性
    addPlatform(startX, GROUND_Y, SEG_W, 80);
    // 30%地刺陷阱，保证不会必死
    if(Math.random()<0.3){
      const sx = startX + randi(180, SEG_W-180);
      addSpike(sx, GROUND_Y, randi(60,120), 30);
    }
    // 检查点
    const segIndex = Math.floor(endX / SEG_W);
    if(segIndex % 2 === 0){ const id = String.fromCharCode('A'.charCodeAt(0) + (segIndex/2)%26); addCheckpoint(endX-60, id); }
    level.rightEdge = endX;
  }

  function cullOld(){
    const minX = camera.x - 1200;
    level.platforms = level.platforms.filter(p=>p.x + p.w > minX);
    level.spikes = level.spikes.filter(s=>s.x + s.w > minX);
    level.coins = level.coins.filter(c=>c.x > minX);
    level.checkpoints = level.checkpoints.filter(f=>f.x > minX);
    level.movers = level.movers.filter(m=>m.x + m.w > minX);
    level.springs = level.springs.filter(sp=>sp.x > minX);
    level.bricks = level.bricks.filter(b=>b.x + b.w > minX && b.hits>0);
  }
  function ensureAhead(){ while(level.rightEdge < player.x + 1400) generateSegment(); }

  // ===== 摄像机（屏幕坐标，Y 向下） =====
  const camera = {x:0,y:0};

  // ===== 玩家物理（Y 向下为正） =====
  const GRAVITY = 2200;
  const RUN_SPEED = 260;
  const AIR_ACCEL = 2200;
  const FRICTION = 2600;
  const JUMP_V = 750; // 起跳速度，约可跳 140px
  const COYOTE_MS = 140; // 土狼时间
  const BUFFER_MS = 140; // 跳跃缓冲
  const MAX_FALL = 1000;
  const SPRING_LOCK_MS = 60; // 弹簧上锁，防止连触

  const player = {
    x: level.spawn.x, y: level.spawn.y, w:28, h:40,
    vx:0, vy:0, onGround:false, hp:3, invul:0,
    lastGroundTime:0, lastJumpPress:-999,
    coins:0, checkpoint:{x:level.spawn.x, y:level.spawn.y, id:'A'},
    dist:0,
    jumpsLeft:2, // 二段跳
    lastSpringTime:-999,
    carryVX:0,
  };

  let collected = new Set();
  let passedFlags = new Set();

  // ===== 游戏状态 =====
  let paused = false, gameWon = false;

  // ===== 基础碰撞 =====
  function aabb(a,b){return !(a.x+a.w<=b.x||b.x+b.w<=a.x||a.y+a.h<=b.y||b.y+b.h<=a.y)}

  function moveAndCollide(dt){
    // 移动平台更新
    for(const m of level.movers){
      const prevX = m.x;
      m.x += m.dir * m.speed * dt; m.vx = m.x - prevX;
      if(m.x < m.ax){ m.x = m.ax; m.dir = 1; }
      if(m.x + m.w > m.bx){ m.x = m.bx - m.w; m.dir = -1; }
    }

    // 水平输入
    let targetVX = 0; if(input.left) targetVX -= RUN_SPEED; if(input.right) targetVX += RUN_SPEED;
    if(player.onGround){ player.vx = lerp(player.vx, targetVX, clamp(dt*10,0,1)); if(Math.abs(player.vx) < 1 && Math.abs(targetVX) < 1) player.vx = 0; }
    else { const dv = targetVX - player.vx; const acc = Math.sign(dv) * AIR_ACCEL * dt; if(Math.abs(dv) < Math.abs(acc)) player.vx = targetVX; else player.vx += acc; }

    // 跳跃触发（首跳支持土狼/缓冲，空中可额外一次二段）
    const pressJump = (input.jump && !input.jumpPressed);
    if(pressJump) player.lastJumpPress = time;
    input.jumpPressed = input.jump;

    let wantFirstJump = (time - player.lastGroundTime <= COYOTE_MS) && (time - player.lastJumpPress <= BUFFER_MS);
    let wantDouble = (!player.onGround) && (player.jumpsLeft>0) && pressJump;
    if(wantFirstJump){ doJump(-JUMP_V); }
    else if(wantDouble){ doJump(-JUMP_V*0.92); }

    // 重力
    player.vy = clamp(player.vy + GRAVITY*dt, -2000, MAX_FALL);

    // 预位移
    let nx = player.x + player.vx*dt;
    let ny = player.y + player.vy*dt;
    player.carryVX = 0;

    // X 轴碰撞（固台 + 移动台 + 砖）
    for(const p of allSolids()){
      const plat = {x:p.x, y:p.y, w:p.w, h:p.h};
      const future = {x:nx, y:player.y, w:player.w, h:player.h};
      if(aabb(future, plat)){
        if(player.vx>0) nx = plat.x - player.w; else if(player.vx<0) nx = plat.x + plat.w;
        player.vx = 0;
      }
    }

    // Y 轴碰撞（顶/落地，包含移动台携带）
    let landedOnMover = null;
    player.onGround = false;
    for(const p of allSolids()){
      const plat = {x:p.x, y:p.y, w:p.w, h:p.h};
      const future = {x:nx, y:ny, w:player.w, h:player.h};
      if(aabb(future, plat)){
        if(player.vy>0){ // 落到顶面
          ny = plat.y - player.h; player.vy = 0; player.onGround = true; player.lastGroundTime = time; player.jumpsLeft = 2; // 落地重置为2段跳
          if(p._isMover) { landedOnMover = p; }
        } else if(player.vy<0){ // 顶到底面
          ny = plat.y + plat.h; player.vy = 0;
          // 顶到碎砖就打碎
          if(p._isBrick){ p.hits--; if(p.hits<=0) p.w=0,p.h=0; if(Math.random()<0.5) addCoin(p.x+p.w/2, p.y-40); }
        }
      }
    }
    if(landedOnMover) player.carryVX = landedOnMover.vx;

    // 弹簧（只在从上往下落入时触发）
    for(const sp of level.springs){
      const box = {x:sp.x-10, y:sp.y-12, w:20, h:12};
      const hero = {x:nx, y:ny, w:player.w, h:player.h};
      if(aabb(hero, box) && (time - player.lastSpringTime > SPRING_LOCK_MS) && player.vy>0){
        player.lastSpringTime = time;
        ny = sp.y - player.h; player.vy = -sp.power; player.onGround=false; player.jumpsLeft = 1; // 弹后仍保留一次二段
      }
    }

    // 地刺伤害
    for(const s of level.spikes){
      const sp = {x:s.x, y:s.y - s.h, w:s.w, h:s.h};
      const box = {x:nx, y:ny, w:player.w, h:player.h};
      if(aabb(box, sp)) damage(1);
    }

    // 应用位移 & 携带
    player.x = nx + player.carryVX; player.y = ny;

    // 里程（以最远 x 记录）
    player.dist = Math.max(player.dist, Math.floor(player.x/10));

    // 防摔落线：掉太深回到旗帜
    if(player.y > GROUND_Y + 800) dieAndRespawn();
  }

  function allSolids(){
    // 固定平台 + 移动平台 + 可破坏砖
    const list = [];
    for(const p of level.platforms) list.push(p);
    for(const m of level.movers) list.push(Object.assign({_isMover:true}, m));
    for(const b of level.bricks) if(b.hits>0) list.push(Object.assign({_isBrick:true}, b));
    return list;
  }

  function doJump(v){
    player.vy = v; player.onGround=false; player.lastJumpPress=-999;
    if(player.jumpsLeft>0) player.jumpsLeft--; updateHUD();
  }

  function damage(d){ if(player.invul>0) return; player.hp=Math.max(0,player.hp-d); player.invul=800; if(player.hp<=0) dieAndRespawn(); updateHUD(); }
  function dieAndRespawn(){ player.x = player.checkpoint.x; player.y = player.checkpoint.y; player.vx=0; player.vy=0; player.hp=3; player.invul=800; player.jumpsLeft=2; updateHUD(); }

  function updateCollectibles(){
    const box = {x:player.x,y:player.y,w:player.w,h:player.h};
    level.coins.forEach((c,i)=>{ if(collected.has(i)) return; const coin={x:c.x-10,y:c.y-10,w:20,h:20}; if(aabb(box,coin)){ collected.add(i); player.coins++; updateHUD(); } });
    level.checkpoints.forEach(flag=>{ const f={x:flag.x-14,y:flag.y-64,w:28,h:64}; if(aabb(box,f)){ player.checkpoint={x:flag.x,y:GROUND_Y-56,id:flag.id}; passedFlags.add(flag.id); updateHUD(); } });
  }

  // ===== 渲染（无 Y 翻转） =====
  function draw(){
    ctx.clearRect(0,0,W,H);

    // 背景渐变
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#0b1220'); g.addColorStop(1,'#101b34');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // 远山（视差）
    ctx.save(); ctx.translate(-(camera.x*0.2)+W/2, -(camera.y*0.2)+H/2);
    ctx.fillStyle = '#0d1a30'; for(let i=-3;i<6;i++) ctx.fillRect(i*800-200, H*0.45, 600, 80); ctx.restore();
    ctx.save(); ctx.translate(-(camera.x*0.4)+W/2, -(camera.y*0.4)+H/2);
    ctx.fillStyle = '#132645'; for(let i=-3;i<6;i++) ctx.fillRect(i*700-100, H*0.6, 500, 90); ctx.restore();

    // 世界层
    ctx.save(); ctx.translate(-camera.x + W/2, -camera.y + H/2);

    // 平台
    for(const p of level.platforms){ ctx.fillStyle='#1f2f57'; ctx.fillRect(p.x,p.y,p.w,p.h); ctx.fillStyle='#243b6f'; ctx.fillRect(p.x, p.y+p.h-6, p.w, 6); }

    // 移动平台
    for(const m of level.movers){ ctx.fillStyle='#25406f'; ctx.fillRect(m.x,m.y,m.w,m.h); ctx.fillStyle='#3a5c9a'; ctx.fillRect(m.x, m.y+m.h-5, m.w, 5); }

    // 弹簧
    for(const sp of level.springs){ ctx.fillStyle = '#ffd166'; ctx.fillRect(sp.x-10, sp.y-12, 20, 12); ctx.fillStyle='#fff2aa'; ctx.fillRect(sp.x-8, sp.y-18, 16, 6); }

    // 砖块
    for(const b of level.bricks){ if(b.hits<=0) continue; ctx.fillStyle='#6b3f2b'; ctx.fillRect(b.x,b.y,b.w,b.h); ctx.fillStyle='#8b5740'; ctx.fillRect(b.x+3,b.y+3,b.w-6,b.h-6); }

    // 地刺
    for(const s of level.spikes){ ctx.fillStyle = '#883a3a'; ctx.fillRect(s.x, s.y - s.h, s.w, s.h); ctx.fillStyle = '#ff6b6b'; for(let x=s.x; x<s.x+s.w; x+=16){ ctx.beginPath(); ctx.moveTo(x, s.y); ctx.lineTo(x+8, s.y - s.h); ctx.lineTo(x+16, s.y); ctx.closePath(); ctx.fill(); } }

    // 旗帜
    for(const f of level.checkpoints) drawFlag(f.x, f.y, passedFlags.has(f.id)?'#6be675':'#8bd1ff');

    // 硬币
    level.coins.forEach((c,i)=>{ if(collected.has(i)) return; drawCoin(c.x,c.y); });

    // 玩家
    drawPlayer();

    ctx.restore();

    if(paused) banner('已暂停 ⏸️','按 P 继续');
  }

  function drawPlayer(){
    const {x,y,w,h,invul} = player;
    const blink = (Math.floor(time/120)%6===0);
    ctx.save(); ctx.translate(x,y);
    ctx.globalAlpha = invul>0 ? (Math.sin(time*0.02)>0?0.5:1) : 1;
    // 影子（脚下）
    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(w/2, h+6, w*0.4, 5, 0, 0, Math.PI*2); ctx.fill();
    // 头在上
    ctx.fillStyle = '#b7ffbf'; ctx.fillRect(2, 0, w-4, 10);
    ctx.fillStyle = '#0b1220'; if(!blink){ ctx.fillRect(6, 6, 3,3); ctx.fillRect(w-9, 6,3,3);} else { ctx.fillRect(6, 5, 8,1); }
    // 身体在下
    ctx.fillStyle = '#6be675'; ctx.fillRect(0, 10, w, h-10);
    ctx.restore();
  }
  function drawCoin(x,y){ ctx.save(); ctx.translate(x,y); const bob=Math.sin(time/200)*4; ctx.fillStyle='#5c4300'; ctx.fillRect(-10,-10+bob,20,20); ctx.fillStyle='#ffd166'; ctx.fillRect(-9,-9+bob,18,18); ctx.fillStyle='#fff2aa'; ctx.fillRect(-3,-3+bob,6,6); ctx.restore(); }
  function drawFlag(x,y,color){ ctx.save(); ctx.translate(x,y); ctx.fillStyle='#c9d2ff'; ctx.fillRect(-2,-64,4,64); ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(2,-60); ctx.lineTo(36,-50); ctx.lineTo(2,-40); ctx.closePath(); ctx.fill(); ctx.restore(); }
  function banner(title, subtitle){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); const bw=Math.min(W-80,520); ctx.fillStyle='rgba(17,24,39,0.85)'; ctx.fillRect((W-bw)/2, H*0.28, bw, 120); ctx.fillStyle='#e6f0ff'; ctx.font='28px system-ui,Segoe UI,Arial'; ctx.fillText(title, (W-bw)/2+20, H*0.28+48); ctx.font='16px system-ui,Segoe UI,Arial'; ctx.fillText(subtitle, (W-bw)/2+20, H*0.28+84); ctx.restore(); }

  function updateHUD(){
    document.getElementById('hp').textContent = player.hp;
    document.getElementById('coins').textContent = player.coins;
    document.getElementById('chk').textContent = player.checkpoint.id;
    document.getElementById('dist').textContent = player.dist;
    document.getElementById('jumps').textContent = player.jumpsLeft+ (player.onGround?1:0);
  }

  // ===== 循环 =====
  let last = now(); let acc = 0; const STEP = 1/120; let running = true; let time = now();
  function step(){
    if(!running) return;
    const t = now(); let dt = (t - last)/1000; last = t; time = t;
    dt = Math.min(dt, 0.033);
    if(!paused){
      ensureAhead(); updateInput();
      acc += dt; while(acc >= STEP){
        moveAndCollide(STEP); updateCollectibles();
        if(player.invul>0) player.invul -= STEP*1000;
        camera.x = lerp(camera.x, player.x + player.w/2 + 120, 0.08);
        camera.y = lerp(camera.y, player.y - 80, 0.08);
        cullOld();
        acc -= STEP;
      }
    }
    draw(); requestAnimationFrame(step);
  }

  function restart(){
    level.platforms.length=0; level.spikes.length=0; level.coins.length=0; level.checkpoints.length=0; level.movers.length=0; level.springs.length=0; level.bricks.length=0;
    collected.clear(); passedFlags.clear();
    addPlatform(-400,GROUND_Y,1200,80); level.rightEdge=800; addCheckpoint(600,'A');
    player.x=level.spawn.x; player.y=level.spawn.y; player.vx=0; player.vy=0; player.hp=3; player.invul=0; player.coins=0; player.onGround=false; player.lastGroundTime=0; player.lastJumpPress=-999; player.dist=0; player.jumpsLeft=2; updateHUD();
  }
  function togglePause(){ paused = !paused; }

  // ===== 轻量级自测（控制台） =====
  function runTests(){
    try{
      console.log('%c[Tests] Running…','color:#8bd1ff');
      // AABB
      console.assert(aabb({x:0,y:0,w:10,h:10},{x:5,y:5,w:10,h:10})===true,'AABB overlap');
      console.assert(aabb({x:0,y:0,w:10,h:10},{x:20,y:20,w:10,h:10})===false,'AABB disjoint');
      // Pause toggle
      const prev = paused; togglePause(); console.assert(paused!==prev,'togglePause'); togglePause();
      // Single jump moves up
      const saveY = player.y; player.onGround=true; player.jumpsLeft=2; player.lastGroundTime=time; player.lastJumpPress=time; input.jump=true; input.jumpPressed=false; moveAndCollide(1/60); input.jump=false; console.assert(player.y < saveY, 'Jump should move up');
      // Double jump raises further
      const yAfterFirst = player.y; // now in air
      input.jump=true; input.jumpPressed=false; moveAndCollide(1/60); input.jump=false; console.assert(player.y < yAfterFirst, 'Double jump should add height');
      // Spring bounce
      addSpring(player.x+5, player.y+player.h+12, 900); const sy=time; moveAndCollide(1/30); console.assert(player.vy<0 || (time-sy)<100, 'Spring should impart upward velocity');
      console.log('%c[Tests] All passed.','color:#6be675');
    }catch(e){ console.error('[Tests] Failed:', e); }
  }

  resize(); updateHUD(); runTests(); step();
})();
</script>
</body>
</html>
